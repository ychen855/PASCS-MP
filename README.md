# Patch Analysis-based Surface Correntropy-induced Sparse Coding and Max-Pooling (PASCS-MP)

This is the geometric feature extraction pipeline for the paper: Chen, Y., Su, Y., Wu, J., Chen, K., Atri, A., Caselli, R.J., Reiman, E.M., Wang, Y. and Alzheimer’s Disease Neuroimaging Initiative, 2023. Combining Blood-Based Biomarkers and Structural MRI Measurements to Distinguish Persons With and Without Significant Amyloid Plaques. bioRxiv, pp.2023-10.

Authors:

	Yanxi Chen, email: ychen855@asu.edu
 	Jianfeng Wu, email: Jianfeng.Wu@asu.edu

If you find this work useful, please cite:
1. Chen, Y., Su, Y., Wu, J., Chen, K., Atri, A., Caselli, R.J., Reiman, E.M., Wang, Y. and Alzheimer’s Disease Neuroimaging Initiative, 2023. Combining Blood-Based Biomarkers and Structural MRI Measurements to Distinguish Persons With and Without Significant Amyloid Plaques. bioRxiv, pp.2023-10.
2. Wu, J., Dong, Q., Gui, J., Zhang, J., Su, Y., Chen, K., Thompson, P.M., Caselli, R.J., Reiman, E.M., Ye, J. and Wang, Y., 2021. Predicting brain amyloid using multivariate morphometry statistics, sparse coding, and Correntropy: Validation in 1,101 individuals from the ADNI and OASIS databases. Frontiers in Neuroscience, 15, p.669595.

## Step 1: Hippocampus registration, segmentation, surface reconstruction and parameterization
## Step 2: Extracting MMS features

Input: Nifti images

Output: Hippocampus surface mesh with MMS features (RD and mTBM)

Steps 1 and 2 can be done by our MTSMS pipeline: https://gsl.lab.asu.edu/mtsms/.

## Step 3: Select patches on the hippocampal surface mesh

This step is to be run by matlab.

Input: JFeatures

Output: Selected patches. Default: MMS_patches.txt

Usage: in run_select_patch.m, set the dataset name and folders containg JFeature files (assuming positive and negative in two folders). Then run run_select_patch.m using matlab.

## Step 4: Correntropy-based sparse coding

This step is implemented by C++ and compiled Linux 64-bit binary is available as bin/run_correntropy. Source code is in src/run_correntropy.cpp.

Input: patches generated by the previous step.

Output: 1) sparse code: MMS_sparse.txt; 2) initial dictionary: MMS_initdict.txt; 3) final dictionary: MMS_dict.txt.

Parameters: 1) lambda: 4.0; 2) sigma: 2.0; 3) feature dim: 1800; 4) patch size: 1008

Usage: ./run_correntropy [PATCH] [SPARSE_CODE] [INITIAL_DICT] [FINAL_DICT] [LAMBDA] [SIGMA] [FEAT_DIM] [PATCH_SIZE]

Example: ./run_correntropy MMS_patches.txt MMS_sparse.txt MMS_initialdict.txt MMS_dict.txt 4.0 2.0 1800 1008

## Step 5: Max-pooling

Input: sparse code generated by the previous step.

Parameters: 1) feature dim: 1800; 2) patch size: 1008.

Output: pooled MMS features.

Usage: ./MaxPooling [FEAT_DIM] [PATCH_SIZE] [SPARSE_CODE] [OUTPUT]

Example: ./MaxPooling 1008 1800 MMS_sparse.txt MMS_features.txt

## Step 6: Downstream tasks.

MMS_features.txt contains the sample feature matrix and can be used in downstream tasks. For example, in Chen, Y., Su, Y., Wu, J., Chen, K., Atri, A., Caselli, R.J., Reiman, E.M., Wang, Y. and Alzheimer’s Disease Neuroimaging Initiative, 2023. Combining Blood-Based Biomarkers and Structural MRI Measurements to Distinguish Persons With and Without Significant Amyloid Plaques. bioRxiv, pp.2023-10., we implemented a random forest classifier for brain amyloid positivity classification.

## If you need a deeper dive into the technical details, here is a list of previous methods and their original publications:

1. Patch Analysis-based Surface Sparse-coding and Max-Pooling (PASS-MP): 

2. PASS: 

3. Stochastic Coordinate Coding: 


